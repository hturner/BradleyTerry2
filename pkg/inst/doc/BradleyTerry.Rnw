% \VignetteIndexEntry{Bradley-Terry models in R}
%\VignetteKeywords{generalized linear model, logistic regression, Jeffreys prior, ranking, tournament analysis, working residuals}
%\VignettePackage{BradleyTerry2}

%%% For jss:
% \documentclass{jss}
% \newcommand{\pkginfo}{}

%%% uncomment for vignette version
\documentclass[nojss]{jss}
\newcommand{\pkginfo}{\small \\[12pt]For \pkg{BradleyTerry2} version \Sexpr{packageDescription("BradleyTerry2")[["Version"]]}, \Sexpr{Sys.Date()}\\\url{http://bradleyterry2.r-forge.r-project.org/}\\[-12pt]}

%% need no \usepackage{Sweave.sty}

\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{thumbpdf}

\setkeys{Gin}{width=0.6\textwidth}
\SweaveOpts{keep.source=TRUE}
%http://www.stat.auckland.ac.nz/~ihaka/downloads/Sweave-customisation.pdf

\newcommand{\R}{\proglang{R}}
\newcommand{\BT}{\pkg{BradleyTerry2}}
\newcommand{\logit}{\mathop{\rm logit}}
\newcommand{\pr}{\mathop{\rm pr}}

\author{Heather Turner\\{\it University of Warwick} \And 
  David Firth\\{\it University of Warwick}}
\Plainauthor{Heather Turner, David Firth}

\title{Bradley-Terry models in R: The \BT\ package 
\pkginfo}
\Plaintitle{Bradley-Terry models in R: The BradleyTerry2 package}
\Shorttitle{Bradley-Terry models in R}

\Abstract{

This is a short overview of the \R\ add-on package \BT, which facilitates the
specification and fitting of Bradley-Terry logit, probit or cauchit
models to pair-comparison data.
Included are the standard `unstructured' Bradley-Terry model, structured
versions in which the parameters are related through a linear predictor to
explanatory variables, and the possibility of an order or `home advantage'
effect or other `contest-specific' effects.
Model fitting is either by maximum likelihood, by penalised
quasi-likelihood (for models which involve a random effect), or by bias-reduced
maximum likelihood in which the first-order asymptotic bias of parameter
estimates is eliminated.  Also  provided are a simple and efficient approach to
handling missing covariate data, and suitably-defined residuals for diagnostic
checking of the linear predictor.
}

\Keywords{generalized linear model, logistic regression, Jeffreys prior, penalised quasi-likelihood, ranking, tournament analysis, working residuals}

\Address{
  David Firth\\
  Department of Statistics\\
  University of Warwick\\
  Coventry\\
  CV4 7AL, UK\\
  E-mail: \email{d.firth@warwick.ac.uk}\\
  URL: \url{http://go.warwick.ac.uk/dfirth}
}

\begin{document}

@ 
<<set_width, echo = FALSE>>=
options(width = 60)
@ %def 


\section{Bradley-Terry model}

\subsection{Introduction}

The Bradley-Terry model \citep{brad:terr:52} assumes that in a `contest' between
any two `players', say player $i$ and player $j$ $(i, j \in \{1,\ldots,K\})$,
the odds that $i$ beats $j$ are $\alpha_i/\alpha_j$, where $\alpha_i$ and
$\alpha_j$ are positive-valued parameters which might be thought of as
representing `ability'.  A general introduction can be found in
\citet{brad:84} or \citet{agre:02}.
Applications are many, ranging from experimental psychology to the analysis of
sports tournaments to genetics (for example, the allelic
transmission/disequilibrium test of \citet{sham:curt:95} is based on a
Bradley-Terry model in which the `players' are alleles).
In typical
psychometric applications the `contests' are comparisons, made by
different human subjects, between pairs of items.

The model can
alternatively be expressed in the logit-linear form
\begin{equation}
\logit[\pr(i\ \mathrm{beats}\ j)]=\lambda_i-\lambda_j,
\end{equation}
where $\lambda_i=\log\alpha_i$ for all $i$.  Thus, assuming independence of all
contests, the parameters $\{\lambda_i\}$ can be estimated by
maximum likelihood using standard software for generalized linear models, with a
suitably specified model matrix.  The primary purpose of the \BT\ package,
implemented in the \R\ statistical computing environment \citep{ihak:gent:96,
R}, is to facilitate the specification and fitting of such models and some
extensions.

The \BT\ package supersedes the earlier \pkg{BradleyTerry} package
\citet{firt:05}, providing a more flexible user interface to allow a wider
range of models to be fitted. In particular, \BT\ allows the inclusion of
simple random effects so that the ability parameters can be related to available
explanatory variables through a linear predictor of the form
$\lambda_i=\sum_{r=1}^p\beta_rx_{ir} + U_i$.  The inclusion of the prediction
error $U_i$ allows for variability between players with equal covariate values
and induces correlation between comparisons with a common player. \BT\ also
allows for general contest-specific effects to be included in the model and
allows the logit link to be replaced, if required, by a different symmetric link
function (probit or cauchit).


\subsection{Example: analysis of journal citations}
\label{citations}

The following comes from page 448 of \citet{agre:02}, extracted from the larger
table of \citet{stig:94}.  The data are counts of citations among four prominent
journals of statistics and are included the \BT\ package as the dataset
\code{citations}:
@
<<CitationData>>=
library(BradleyTerry2)
data(citations)
@

@
<<CitationData2>>=
citations
@ %def
Thus, for example, \emph{Biometrika} was cited 498 times by papers in
\emph{JASA} during the period under study.  In order to fit a Bradley-Terry
model to these data using \code{BTm} from the \BT\ package, the data must
first be converted to binomial frequencies. That is, the data need to be
organised into pairs (\code{player1}, \code{player2}) and corresponding
frequencies of wins and losses for \code{player1} against
\code{player2}. The \BT\ package provides the utility function
\code{countsToBinomial} to convert a contingency table of
wins to the format just described:
@
<<countsToBinomial>>=
citations.sf <- countsToBinomial(citations)
names(citations.sf)[1:2] <- c("journal1", "journal2")
citations.sf
@ %def

The binomial response can then be modelled by the difference in player abilities
as follows:
@
<<citeModel>>=
citeModel <- BTm(cbind(win1, win2), journal1, journal2, ~ journal, 
    id = "journal", data = citations.sf)
citeModel
@ %def
The coefficients here are maximum likelihood estimates of $\lambda_2, \lambda_3,
\lambda_4$, with $\lambda_1$ (the log-ability for \emph{Biometrika}) set to zero
as an identifying convention.

The one-sided model formula
\begin{verbatim}
      ~ journal
\end{verbatim}
specifies the model for player ability, in this case the `citeability' of the
journal. The \code{id} argument specifies that \code{"journal"} is the
name to be used for the factor that identifies the player --- the values of which
are given here by \code{journal1} and \code{journal2} for the first and
second players respectively. Therefore in this case a separate
citeability parameter is estimated for each journal.

If a different `reference' journal is required, this can be achieved using the
optional \code{refcat} argument: for
example, making use of \code{update} to avoid re-specifying the whole model,
@
<<citeModelupdate>>=
update(citeModel, refcat = "JASA")
@ %def
--- the same model in a different parameterization.

The use of the standard Bradley-Terry model for this application might perhaps
seem rather questionable --- for example, citations within a published paper can
hardly be considered independent, and the model discards potentially important
information on self-citation.  \citet{stig:94} provides arguments to defend the
model's use despite such concerns.

\section{Abilities predicted by explanatory variables}

\subsection{`Player-specific' predictor variables}

In some application contexts there may be `player-specific' explanatory
variables available, and it is then natural to consider model simplification of
the form
\begin{equation}
\lambda_i=\sum_{r=1}^p\beta_rx_{ir} + U_i,
\end{equation}
in which ability of each player $i$ is related to explanatory variables
$x_{i1},\ldots,x_{ip}$ through a linear predictor with coefficients
$\beta_1,\ldots,\beta_p$; the $\{U_i\}$ are independent errors.
Dependence of the player abilities on explanatory variables can be specified via the
\code{formula} argument, using the standard \emph{S}-language
model formulae.  The difference in the abilities of player $i$
and player $j$ is modelled by
\begin{equation}
\sum_{r=1}^p\beta_rx_{ir} - \sum_{r=1}^p\beta_rx_{jr} + U_i - U_j,
\end{equation}
where $U_i \sim N(0, \sigma^2)$ for all $i$. The Bradley-Terry model is then a
generalized linear mixed model, which the \code{BTm} function currently
fits by using the penalized quasi-likelihood algorithm of \citet{bres:93}.

As an illustration, consider the following simple model for the
\code{flatlizards} data, which predicts the fighting ability of Augrabies flat
lizards by body size (snout to vent length):
@
<<lizModel>>=
options(show.signif.stars = FALSE)
data(flatlizards)
lizModel <- BTm(1, winner, loser, ~ SVL[..] + (1|..), 
                data = flatlizards)
@ %def
Here the winner of each fight is compared to the loser, so the outcome is
always 1.  The special name ``\code{..}'' appears in the formula as the default
identifier for players, in the absence of a user-specified \code{id} argument.
The values of this factor are given by \code{winner} for the winning lizard
and \code{loser} for the losing lizard in each contest. %Since \code{winner}
%and \code{loser} are specific instances of the factor \code{..}, they must
%share the same set of levels (one for each lizard). 
%The factors \code{winner}and \code{loser} 
These factors are provided in the data frame \code{contests} that is the
first element of the list object \code{flatlizards}. The second element of
\code{flatlizards} is another data frame, \code{predictors}, containing
measurements on the observed lizards, including \code{SVL}, which is the snout
to vent length. Thus \code{SVL[..]} represents the snout to vent length
indexed by lizard (\code{winner} or \code{loser} as appropriate).  Finally a
random intercept for each lizard is included using the bar notation familiar
to users of the \pkg{lme4} package (note that this is the only random effect
structure currently implemented in \pkg{BradleyTerry2}).

The fitted model is summarized below:
@ 
<<summarize_lizModel>>=
summary(lizModel)
@ %def 
The coefficient of snout to vent length is weakly significant, however the
standard deviation of the random effects is large and highly significant,
suggesting that the model is a poor fit. A more appropriate model is
considered in the next section.

\subsection{Missing values}

The contest data may include all possible pairs of players and hence rows of
missing data corresponding to players paired with themselves. Such rows
contribute no information to the Bradley-Terry model and are simply discarded by
\code{BTm}.

Where there are missing values in player-specific \emph{predictor} (or
\emph{explanatory}) variables which appear in the formula, it
will typically be very wasteful to discard all contests involving players for
which some values are missing. Instead, such cases are accommodated by the
inclusion of one or more parameters in the model.  If, for example, player $1$
has one or more of its predictor values $x_{11},\ldots,x_{1p}$ missing, then the
combination of (1) and (3) above yields
\[
\logit[\pr(1\ \mathrm{beats}\ j)]=\lambda_1 - \left(\sum_{r=1}^p\beta_rx_{jr} + U_j\right),
\]
for all other players $j$.  This results in the inclusion of a `direct' ability
parameter for each player having missing predictor values, in addition to the
common coefficients $\beta_1,\ldots,\beta_p$ --- an approach which will be
appropriate when the missingness mechanism is unrelated to contest success.  The
same device can be used also to accommodate any user-specified departures from a
structured Bradley-Terry model, whereby some players have their abilities
determined by the linear predictor but others do not.

In the original analysis of the \code{flatlizards} data \citep{whit:06}, the
final model included the first and third principal compenents
of the spectral reflectance from the throat (representing brightness and UV intensity
respectively) as well as head length and the snout to vent length seen in our
earlier model. The spectroscopy data was missing for two lizards, therefore
the ability of these lizards was estimated directly. The following fits this
model, with the addition of a random intercept as before:
@ 
<<lizModel2>>=
summary(BTm(1, winner, loser,
            ~ throat.PC1[..] + throat.PC3[..] +
            head.length[..] + SVL[..] + (1|..),
            data = flatlizards))
@ %def 
We find that the random effects 
%For an illustration of this device in action, see \code{example(flatlizards)}:
%two of the lizards in that study (\code{lizard096} and \code{lizard099})
%have some missing covariate data, and those two lizards therefore have their
%abilities estimated by separate coefficients.

\subsection{Order effect}
\label{sec:order}

In certain types of application some or all contests have an associated `bias',
related to the order in which items are presented to a judge or with the
location in which a contest takes place, for example.  A natural extension of
the Bradley-Terry model (1) is then
\[
\logit[\pr(i\ \mathrm{beats}\ j)]=\lambda_i-\lambda_j + \delta z,
\]
where $z=1$ if $i$ has the supposed advantage and $z=-1$ if $j$ has it.  (If the
`advantage' is in fact a disadvantage, $\delta$ will be negative.)  The scores
$\lambda_i$ then relate to ability in the absence of any such advantage.

As an example, consider the baseball data given in \citet{agre:02}, page 438:
@
<<baseball>>=
data(baseball)
head(baseball)
@ %def
The dataset records the home wins and losses for each baseball team against each
of the 6 other teams in the dataset. The \code{head} function is used to
show the first 6 records, which are the Milwaukee home games. We see for
example that Milwaukee played 7 home games against Detroit and won 4 of them.
The `standard' Bradley-Terry model without a home-advantage parameter will be
fitted if no formula is specified in the call to \code{BTm}:
@
<<baseballModel>>=
data(baseball)
baseballModel1 <- BTm(cbind(home.wins, away.wins), home.team, away.team,
                      data = baseball, id = "team")
summary(baseballModel1)
@ %def
The reference team is Baltimore, estimated to be the weakest of these seven,
with Milwaukee and Detroit the strongest.

In the above, the ability of each team is modelled simply as \code{~ team} where 
the values of the factor \code{team} are given by \code{home.team} for the
first team and \code{away.team} for the second team in each game. To
estimate the home-advantage effect, an additional variable is required to
indicate whether the team is at home or not. Therefore data frames
containing both the team factor and this new indicator variable are required
in place of the factors \code{home.team} and \code{away.team} in the call to
\code{BTm}. This is achieved here by over-writing the \code{home.team} and
\code{away.team} factors in the \code{baseball} data frame: 
@
<<baseballDataUpdate>>=
baseball$home.team <- data.frame(team = baseball$home.team, at.home = 1)
baseball$away.team <- data.frame(team = baseball$away.team, at.home = 0)
@ %def
The \code{at.home} variable is needed for both the home team and the 
away team, so that it can be differenced as appropriate in the linear
predictor. With the data organised in this way, the ability formula can now be
updated to include the \code{at.home} variable as follows:
@
<<baseballModelupdate>>=
baseballModel2 <- update(baseballModel1, formula = ~ team + at.home)
summary(baseballModel2)
@ %def
This reproduces the results given on page 438 of \citet{agre:02}: the home team
has an estimated odds-multiplier of $\exp(0.3023) = 1.35$ in its favour.

\subsection{More general (contest-specific) predictors}

The `home advantage' effect is a simple
example of a contest-specific predictor.  Such predictors are necessarily
interaction terms, between aspects of the contest and (aspects of) the two
`players' involved.

For more elaborate examples of such effects, see \code{?chameleons} and
\code{?CEMS}.  The former includes an `experience' effect, which changes
through time, on the fighting ability of male chameleons.  The latter
illustrates a common situation in psychometric applications of the
Bradley-Terry model, where \emph{subjects} express preference for one of two
\emph{objects} (the `players'), and it is the influence on the results of
subject attributes that is of primary interest.

As an illustration of the way in which such effects are specified, consider
the following model specification taken from the examples in \code{?CEMS},
where data on students' preferences in relation to six European management
schools is analysed.
@
<<CEMSmodel>>=
data(CEMS)
table8.model <-  BTm(outcome = cbind(win1.adj, win2.adj),
    player1 = school1, player2 = school2, formula = ~ .. + 
    WOR[student] * LAT[..] +  DEG[student] * St.Gallen[..] +
    STUD[student] * Paris[..] + STUD[student] * St.Gallen[..] +
    ENG[student] * St.Gallen[..] + FRA[student] * London[..] +
    FRA[student] * Paris[..] + SPA[student] * Barcelona[..] +
    ITA[student] * London[..] + ITA[student] * Milano[..] +
    SEX[student] * Milano[..],
    refcat = "Stockholm", data = CEMS)
@ %def
This model reproduces results from Table~8 of \cite{ditt:01} apart
from minor differences due to the different treatment of ties. Here the
outcome is the binomial frequency of preference for \code{school1} 
over \code{school2}, with ties counted as half a `win' and half a `loss'. The
formula specifies the model for school `ability' or worth. In this formula,
the default label ``\code{..}'' represents the school (with values given by
\code{school1} or \code{school2} as appropriate) and \code{student} is a
factor specifying the student that made the comparison. The remaining
variables in the formula use R's standard indexing mechanism to include
student-specific variables, e.g. \code{WOR}: whether or not the student was in
full-time employment, and school-specific variables, e.g. \code{LAT}: whether
the school was in a `Latin' city. Thus there are three types of variables:
contest-specific (\code{school1}, \code{school2}, \code{student}),
subject-specific (\code{WOR}, \code{DEG}, \ldots) and object-specific
(\code{LAT}, \code{St.Gallen}, \ldots). These three types of variables are
provided in three data frames, contained in the list object \code{CEMS}.

\section{Ability scores}

The function \code{BTabilities} extracts estimates and standard errors for
the log-ability scores $\lambda_1, \ldots,\lambda_K$.  These will either be
`direct' estimates, in the case of the standard Bradley-Terry model or for
players with one or more missing predictor values, or `model-based' estimates
of the form $\hat\lambda_i=\sum_{r=1}^p\hat\beta_rx_{ir}$ for players whose ability is
predicted by explanatory variables.

As a simple illustration, team ability estimates in the
home-advantage model for the \code{baseball} data are obtained by:
@
<<BTabilities>>=
BTabilities(baseballModel2)
@ %def
This gives, for each team, the estimated ability when the team
enjoys no home advantage.

Similarly, ability estimates (for the nine experimental settings found in \code{springall.predictors}) can be obtained for the response-surface model of
\cite{spri:73}:
@
<<BTabilities2>>=
BTabilities(springall.model)
@ %def

The ability estimates in an un-structured Bradley-Terry model are particularly well suited to presentation using the device of \emph{quasi variances} \citep{firt:04}.  The \pkg{qvcalc} package (version 0.8-5 or later) contains a function of the same name which does the necessary work:
\begin{Sinput}
> library(qvcalc)
> baseball.qv <- qvcalc(BTabilities(baseballModel2))
> plot(baseball.qv, 
+      levelNames = c("Bal", "Bos", "Cle", "Det", "Mil", "NY", "Tor"))
\end{Sinput}
\begin{figure}[!tbph]
    \begin{center}
        \includegraphics{baseball-qvplot.pdf}
    \end{center}
    \caption{Estimated relative abilities of baseball teams}
    \label{fig:qvplot}
\end{figure}

\section{Residuals}

There are two main types of residuals available for a Bradley-Terry model object.

First, there are residuals obtained by the standard methods for models of class
\code{"glm"}.  These all deliver one residual for each contest or type of
contest.  For example, Pearson residuals for the model
\code{springall.model} can be obtained simply by
@
<<residuals>>=
res.pearson <- round(residuals(springall.model), 3)
head(cbind(springall$contests, res.pearson))
@ %def

More useful for diagnostics on the linear predictor $\sum\beta_rx_{ir}$ are
`player'-level residuals, obtained by using the function \code{residuals}
with argument \code{type = "grouped"}.  These residuals can then be
plotted against other player-specific variables.
@
<<BTresiduals>>=
res <- residuals(springall.model, type = "grouped")
#  with(springall$predictors, plot(flav, res))
#  with(springall$predictors, plot(gel, res))
@ %def
These residuals estimate the error in the linear predictor; they are obtained by
suitable aggregation of the so-called `working' residuals from the model fit.
The \code{weights} attribute
indicates the relative information in these residuals --- weight is roughly
inversely proportional to variance --- which may be useful for plotting and/or
interpretation; for example, a large residual may be of no real concern if based
on very little information. Weighted least-squares regression of these residuals
on any variable already in the model is null.  For example:
@
<<residualWLS>>=
lm(res ~ flav, weights = attr(res, "weights"), data = springall$predictors)
lm(res ~ gel, weights = attr(res, "weights"), data = springall$predictors)
@ %def %$

\section{Bias-reduced estimates}

Estimation of the Bradley-Terry model in \pkg{BTm} is by default
(when there are no random effects in the model)
computed by maximum likelihood, using an internal call to the
\code{glm} function.  An alternative  is to fit by bias-reduced
maximum likelihood \citep{firt:93}: this requires additionally the
\pkg{brglm}
package, and is specified by the optional argument \code{br = TRUE}.  The
resultant effect, namely removal of first-order asymptotic bias in
the estimated coefficients, is often quite small.  One notable feature of
bias-reduced fits is that all estimated coefficients and standard errors are
necessarily finite, even in situations of `complete separation' where MLEs take
infinite values \citep{hein:sche:02}.

\section{Model search}

In addition to \code{update()} as illustrated above, methods for the
generic functions \code{add1()}, \code{drop1()} and
\code{anova()} are provided. These
can be used to investigate the effect of adding or removing a variable, whether
that variable is contest-specific, such as an order effect, or player-specific;
and to compare the fit of nested models.

%These can be used in the standard way for model elaboration or specialization,
%and their availability also allows the use of \texttt{\color{black} step()} for
%automated exploration of a set of candidate player-specific predictors.

\section{Setting up the data}

\subsection{Contest-specific data}

The \code{outcome} argument of \code{BTm} represents a
binomial response and can be supplied in any of the formats allowed by the
\code{glm} function. That is, either a two-column matrix with the columns
giving the number of wins and losses (for \code{player1}), a factor where
the first level denotes a
loss and all other levels denote a win, or a binary variable where 0 denotes a
loss and 1 denotes a win. Each row represents either a single contest or a set
of contests between the same two players.

The \code{player1} and \code{player2} arguments are either factors
specifying the two players in each contest, or data frames containing such factors, along
with any contest-level variables that are player-specific, such as the
\code{at.home} variable seen in Section \ref{sec:order}. The id factors
should be named as specified by the \code{id} argument if given in a data
frame and should have identical levels, since they represent a particular
sample of the full set of players.

Any \emph{contest-specific} variables should be of the
same length as the variables specified in the \code{outcome},
\code{player1} and \code{player2} arguments.  Sometimes this is
achieved most economically by appropriate indexing: see, for example,
\code{?CEMS}, where student-specific variables are stored in a data frame
with one row per student rather than one row per `contest'.

An offset in the model can be specified by
using the \code{offset} argument to \code{BTm}.

To use only certain rows of the data in the analysis, the \code{subset}
argument may be used in the call to \code{BTm}.  This should either be a
logical vector of the same length as the binomial response, or a numeric vector
containing the indices of rows to be used.

\subsection{Player-specific data}

Variables indexed by the levels of \code{player1} and \code{player2},
i.e., indexed by \code{id}, are said to be `player-specific'.
The safest approach is to put all potential predictor
(explanatory) variables  --- including factors and any offset term --- into a
data frame with one row per (potential) player,
and with row names the names of players exactly as used in variables passed to
the \code{player1} and \code{player2} arguments of \code{BTm}.
Such a data frame
should then be included in the list specified as the \code{data} argument
of \code{BTm} to specify where predictors (and any offset) can be found.

Player-specific offsets should be included in the formula by using the
\code{offset} function.

\subsection[Converting data from the format required by the earlier BradleyTerry package]{Converting data from the format required by the earlier \pkg{BradleyTerry} package}

The \pkg{BradleyTerry} package described in \citet{firt:05} required contest/comparison results to be in a data frame with columns named \code{winner}, \code{loser} and \code{Freq}.  The following example shows how \code{xtabs} and \code{countsToBinomial} can be used to convert such data for use with the \code{BTm} function in \pkg{BradleyTerry2}:
\begin{Sinput}
> library(BradleyTerry)  ## the /old/ BradleyTerry package
> ## load data frame with columns "winner", "loser", "Freq"
> data(citations, package = "BradleyTerry")
> ## convert to 2-way table of counts
> citations <- xtabs(Freq ~ winner + loser, citations)
> ## convert to a data frame of binomial observations
> citations.sf <- countsToBinomial(citations)  
\end{Sinput}
The \code{citations.sf} data frame can then be used with \code{BTm} as shown in Section \ref{citations}.



\section[A list of the functions provided in BradleyTerry2]{A list of the functions provided in \pkg{BradleyTerry2}}

The standard \R\ help files provide the definitive reference.  Here we simply
list the main user-level functions and their arguments, as a
convenient overview:
@
<<functions, echo = FALSE>>=
## cf. prompt
options(width = 55)
for (fn in getNamespaceExports("BradleyTerry2")) {
    name <- as.name(fn)
    args <- formals(fn)
    n <- length(args)
    arg.names <- arg.n <- names(args)
    arg.n[arg.n == "..."] <- "\\dots"
    is.missing.arg <- function(arg) typeof(arg) == "symbol" &&
        deparse(arg) == ""
    Call <- paste(name, "(", sep = "")
        for (i in seq_len(n)) {
        Call <- paste(Call, arg.names[i], if (!is.missing.arg(args[[i]]))
            paste(" = ", paste(deparse(args[[i]]),
                collapse = "\n"), sep = ""), sep = "")
        if (i != n)
            Call <- paste(Call, ", ", sep = "")
    }
    Call <- paste(Call, ")", sep = "")
    cat(deparse(parse(text = Call)[[1]], width.cutoff = 50), fill = TRUE)
}
options(width = 60)
@ %def

\section[A note on the treatment of ties]{A note on the treatment of ties}

The present version of \BT\ provides no sophisticated facilities for handling
tied contests/comparisons; the well-known models of \cite{rao:kupp:67}
and \cite{davi:70} are not implemented here.  At present the \code{BTm}
function requires a binary or binomial response variable, the third (`tied')
category of response is not allowed.

In several of the data examples (e.g., \code{?CEMS}, \code{?springall},
\code{?sound.fields}),
ties are handled by the crude but simple device of adding half of a `win' to
the tally for each player involved; in each of the examples where this has been done it is found that the result is very similar, after a simple re-scaling, to the more sophisticated analyses that have appeared in the literature.

It is likely that a future version of \BT\ will have a more general method for handling ties.

\section*{Acknowledgments}

This work was supported by the UK Engineering and Physical Sciences Research
Council.


\bibliography{BradleyTerry}

\end{document}

