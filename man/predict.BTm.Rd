% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.BTm.R
\name{predict.BTm}
\alias{predict.BTm}
\title{Predict Method for Bradley-Terry Models}
\usage{
\method{predict}{BTm}(object, newdata = NULL,
  level = ifelse(is.null(object$random), 0, 1), type = c("link",
  "response", "terms", "ability"), se.fit = FALSE, dispersion = NULL,
  terms = NULL, na.action = na.pass, ...)
}
\arguments{
\item{object}{a fitted object of class \code{"BTm"}}

\item{newdata}{(optional) a single data frame of contest-level data or a
list of data frames in which to look for variables with which to predict.
If omitted, the fitted linear predictors are used.}

\item{level}{for models with random effects: an integer vector giving the
level(s) at which predictions are required. Level zero corresponds to
population-level predictions (fixed effects only), whilst level one
corresponds to the player-level predictions (full model) which are NA for
contests involving players not in the original data. By default, \code{level = 0}
for a fixed effects model, \code{1} otherwise.}

\item{type}{the type of prediction required.  The default \code{"link"}is to
predict contest outcomes on the scale of the linear predictors, i.e. the
log-odds (probabilities on logit scale) that the first player wins. The
alternative \code{"response"} is on the scale of the binomial response variable,
i.e. the predicted probability that the first player wins. The \code{"terms"}
option returns a matrix giving the fitted values of each term in the model
formula on the linear predictor scale (fixed effects only). If
\code{type = "ability"}, the fitted ability for each player in the contest is
returned. When predicting abilities with new data, it is valid to specify
only the first player (or only the second player) in a "contest".}

\item{se.fit}{logical switch indicating if standard errors are required.}

\item{dispersion}{a value for the dispersion, not used for models with
random effects. If omitted, that returned by \code{summary} applied to the
object is used, where applicable.}

\item{terms}{with \code{type ="terms"} by default all terms are returned.  A
character vector specifies which terms are to be returned.}

\item{na.action}{function determining what should be done with missing
values in \code{newdata}.  The default is to predict \code{NA}.}

\item{\dots}{further arguments passed to or from other methods.}
}
\value{
If \code{se.fit = FALSE}, a vector or matrix of predictions.  If
\code{se = TRUE}, a list with components \item{fit }{Predictions}
\item{se.fit }{Estimated standard errors}
}
\description{
Obtain predictions and optionally standard errors of those predictions from
a fitted Bradley-Terry model.
}
\details{
If \code{newdata} is omitted the predictions are based on the data used for
the fit.  In that case how cases with missing values in the original fit are
treated is determined by the \code{na.action} argument of that fit.  If
\code{na.action = na.omit} omitted cases will not appear,
whereas if \code{na.action = na.exclude} they will appear (in predictions
and standard errors), with value \code{NA}.  See also \code{[napredict()]}.
}
\examples{

## The final model in example(flatlizards)
result <- rep(1, nrow(flatlizards$contests))
Whiting.model3 <- BTm(1, winner, loser, ~ throat.PC1[..] + throat.PC3[..] +
                      head.length[..] + SVL[..] + (1|..),
                      family = binomial(link = "probit"),
                      data = flatlizards, trace = TRUE)

## `new' data for contests between four of the original lizards
## factor levels must correspond to original levels, but unused levels
## can be dropped - levels must match rows of predictors
newdata  <- list(contests = data.frame(
                 winner = factor(c("lizard048", "lizard060"),
                 levels = c("lizard006", "lizard011", 
                            "lizard048", "lizard060")),
                 loser = factor(c("lizard006", "lizard011"),
                 levels = c("lizard006", "lizard011", 
                            "lizard048", "lizard060"))
                 ),
                 predictors = flatlizards$predictors[c(3, 6, 27, 33), ])

predict(Whiting.model3, level = 1, newdata = newdata)

## same as
predict(Whiting.model3, level = 1)[1:2]

## introducing a new lizard
newpred <- rbind(flatlizards$predictors[c(3, 6, 27),
                     c("throat.PC1","throat.PC3", "SVL", "head.length")],
                 c(-5, 1.5, 1, 0.1))
rownames(newpred)[4] <- "lizard059"

newdata  <- list(contests = data.frame(
                 winner = factor(c("lizard048", "lizard059"),
                 levels = c("lizard006", "lizard011", 
                            "lizard048", "lizard059")),
                 loser = factor(c("lizard006", "lizard011"),
                 levels = c("lizard006", "lizard011", 
                            "lizard048", "lizard059"))
                 ),
                 predictors = newpred)

## can only predict at population level for contest with new lizard
predict(Whiting.model3, level = 0:1, se.fit = TRUE, newdata = newdata)

## predicting at specific levels of covariates

## consider a model from example(CEMS)
table6.model <-  BTm(outcome = cbind(win1.adj, win2.adj),
                     player1 = school1, player2 = school2,
                     formula = ~ .. +
                         WOR[student] * Paris[..] +
                         WOR[student] * Milano[..] +
                         WOR[student] * Barcelona[..] +
                         DEG[student] * St.Gallen[..] +
                         STUD[student] * Paris[..] +
                         STUD[student] * St.Gallen[..] +
                         ENG[student] * St.Gallen[..] +
                         FRA[student] * London[..] +
                         FRA[student] * Paris[..] +
                         SPA[student] * Barcelona[..] +
                         ITA[student] * London[..] +
                         ITA[student] * Milano[..] +
                         SEX[student] * Milano[..],
                     refcat = "Stockholm",
                     data = CEMS)
                     
## estimate abilities for a combination not seen in the original data

## same schools
schools <- levels(CEMS$preferences$school1)
## new student data
students <- data.frame(STUD = "other", ENG = "good", FRA = "good", 
                       SPA = "good", ITA = "good", WOR = "yes", DEG = "no",
                       SEX = "female", stringsAsFactors = FALSE)
## set levels to be the same as original data    
for (i in seq_len(ncol(students))){
    students[,i] <- factor(students[,i], levels(CEMS$students[,i]))
}
newdata <- list(preferences = 
    data.frame(student = factor(500), # new id matching with `students[1,]`
               school1 = factor("London", levels = schools),
               school2 = factor("Paris", levels = schools)),
    students = students,
    schools = CEMS$schools)

## warning can be ignored as model specification was over-parameterized
predict(table6.model, newdata = newdata)

## if treatment contrasts are use (i.e. one player is set as the reference
## category), then predicting the outcome of contests against the reference
## is equivalent to estimating abilities with specific covariate values

## add student with all values at reference levels 
students <- rbind(students,
    data.frame(STUD = "other", ENG = "good", FRA = "good", 
               SPA = "good", ITA = "good", WOR = "no", DEG = "no",
               SEX = "female", stringsAsFactors = FALSE))
## set levels to be the same as original data    
for (i in seq_len(ncol(students))){
    students[,i] <- factor(students[,i], levels(CEMS$students[,i]))
}
newdata <- list(preferences = 
    data.frame(student = factor(rep(c(500, 502), each = 6)), 
               school1 = factor(schools, levels = schools),
               school2 = factor("Stockholm", levels = schools)),
    students = students,
    schools = CEMS$schools)
    
predict(table6.model, newdata = newdata, se.fit = TRUE)

## the second set of predictions (elements 7-12) are equivalent to the output 
## of BTabilities; the first set are adjust for `WOR` being equal to "yes"
BTabilities(table6.model)

}
\seealso{
\code{\link[=predict.glm]{predict.glm()}}, \code{\link[=predict.glmmPQL]{predict.glmmPQL()}}
}
\author{
Heather Turner
}
\keyword{models}
